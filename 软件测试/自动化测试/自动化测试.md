---
title: 自动化测试
typora-root-url: ./自动化测试/
toc: true
date: 2022-10-18 13:36:04
tags: 
- 软件测试
- 自动化测试
categories: 
- 软件测试
- 自动化测试
description: 
---

# 元素定位

## id定位

![image-20221026094950071](https://raw.githubusercontent.com/azwwz/halo-synology-picture1/master/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/image-20221026094950071.png)

> 从上面定位到的元素属性中可以看到有个id属性：id="username"，这里可以通过id属性定位到这个元素。定位到用户名输入框后，需要对其赋值，这里用send_keys( )方法进行文本输入。
> 如果需要对其单击操作，可以使用click( )方法。格式：find_element_by_id("")

```python
实例：
（1）进入人力资源综合服务系统登录页面；
（2）输入用户名。
在PyCharm中进行代码编写：
from selenium import webdriver
driver=webdriver.Chrome()
driver.get("http://192.168.X.XXX/suthr/logon")
#进入人力资源综合服务系统登录页面
driver.find_element_by_id("username").send_keys(" hrteacher")
#通过id()方法定位页面元素，输入用户名
```

## name定位

> 在编写自动化脚本的时候，如果页面中某个元素没有id属性，那就没有办法通过id属性定位页面元素，但是如果页面中存在唯一的name属性，那么就可以使用name元素来定位。
> 以人力资源综合服务系统登录页面的用户名输入框为例，先打开人力资源系统登录页面，选择用户名输入框，右击查看元素，如图所示。

![image-20221026095423400](https://raw.githubusercontent.com/azwwz/halo-synology-picture1/master/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/image-20221026095423400.png)

> 从定位到的元素属性可以看到有个name属性：name="username"，这里可以通过其name属性定位到这个元素。定位到用户名输入框后，需要对其赋值。

```python
实例：
（1）进入人力资源综合服务系统登录页面；
（2）输入用户名。
在PyCharm中进行代码编写：
from selenium import webdriver
driver=webdriver.Chrome()
driver.get("http://192.168.X.XXX/suthr/logon")
#进入人力资源综合服务系统登录页面
driver.find_element_by_name("username").send_keys("hrteacher")
#通过name()方法定位页面元素，输入用户名
```

## xpath定位

> xpath定位是一种路径定位方式，主要依赖元素通过绝对路径或者相关路径来定位，当进行手动编写路径的时候，由于绝对路径需要从头到尾一级一级地往下编写，当遇到元素路径比较深的时候，写起来很麻烦，而且容易出错，且绝对路径xpath执行效率比较低，一般使用比较少。通常使用xpath相对路径和属性定位。由于这里用到有关于网页元素的相关知识（即XML知识），因此下面对这些知识进行讲解。

```xml
我们将在下面的例子中使用如下XML文档。
<?xml version="1.0" encoding="UTF-8"?>
<bookstore>
<book>
 <title lang="eng">Harry Potter</title>
 <price>29.99</price>
</book>
<book>
 <title lang="eng">Learning XML</title>
 <price>39.95</price>
</book>
</bookstore>

```

> 1）选取节点：xpath使用路径表达式在XML文档中选取节点，xpath路径表达式及其描述如表所示。

![image-20221026095729734](https://raw.githubusercontent.com/azwwz/halo-synology-picture1/master/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/image-20221026095729734.png)

> 2）选取未知节点：xpath通配符可用来选取未知的XML元素，xpath通配符及其描述，如表所示。

![image-20221026095747661](https://raw.githubusercontent.com/azwwz/halo-synology-picture1/master/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/image-20221026095747661.png)

![image-20221026095757202](https://raw.githubusercontent.com/azwwz/halo-synology-picture1/master/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/image-20221026095757202.png)

> 3）选取若干路径：通过在路径表达式中使用“|”运算符，可以选取若干路径。在表中列出了一些路径表达式及其结果。

![image-20221026095834596](https://raw.githubusercontent.com/azwwz/halo-synology-picture1/master/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/image-20221026095834596.png)

> 上面的定位方式都是通过元素的某个属性来定位的，还可以通过路径导航实现某个元素的定位，这个时候就可以用xpath解决。
> xpath是一种路径语言，除了上面讲到的手工编写外，还可以直接复制到xpath的路径，然后编写脚本。
> 以人力资源综合服务系统登录页面为例，如图所示。格式：find_element_by_xpath("")

![image-20221026095859089](https://raw.githubusercontent.com/azwwz/halo-synology-picture1/master/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/image-20221026095859089.png)

```python
实例：
（1）进入人力资源综合服务系统登录页面；
（2）输入用户名。
在PyCharm中进行代码编写：
from selenium import webdriver
driver=webdriver.Chrome()
driver.get("http://192.168.X.XXX/suthr/logon")
#进入人力资源综合服务系统登录页面
driver.find_element_by_css_selector('#password').send_keys("hrteacher")
#通过css_selector()方法定位页面元素，输入用户名
```

## css_selector定位

> css_selector定位是另外一种通过路径导航实现某个元素的定位方法，此方法比xpath更为简洁，运行速度更快。可以通过定位到某个页面元素后，直接右击选择相应命令，然后进行脚本编写。
> 以人力资源综合服务系统登录页面为例，如图所示。格式：find_element_by_css_selecto("")

![image-20221026095955998](https://raw.githubusercontent.com/azwwz/halo-synology-picture1/master/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/image-20221026095955998.png)

```python
实例：
（1）进入人力资源综合服务系统登录页面；
（2）输入用户名。
在PyCharm中进行代码编写：
from selenium import webdriver
driver=webdriver.Chrome()
driver.get("http://192.168.X.XXX/suthr/logon")
#进入人力资源综合服务系统登录页面
driver.find_element_by_css_selector('#password').send_keys("hrteacher")
#通过css_selector()方法定位页面元素，输入用户名

```

## link_text定位

> link_text是根据超链接的文本来定位，如果要单击超链接文本，进行从一个页面跳转到另元素定位方外一个页面，那么可以使用此元素定位方式进行定位。
> 以人力资源综合服务系统中的人资工作台按钮为例，右击查看元素，如图所示。通过元素属性可以分析出，当标签属性为a，且href ="/suthr/home"，说明它是个超链接，对于这种元素，可以用link_text方法。格式：find_element_by_link_text("")

![image-20221026100033560](https://raw.githubusercontent.com/azwwz/halo-synology-picture1/master/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/image-20221026100033560.png)

```python
实例：
（1）进入人力资源综合服务系统登录页面；
（2）输入用户名和密码；
（3）单击“登录”按钮；
（4）单击“人资工作台”按钮。
在PyCharm中进行代码编写：
from selenium import webdriver
driver=webdriver.Chrome()
driver.get("http://192.168.X.XXX/suthr/logon")
#进入人力资源综合服务系统登录页面
driver.find_element_by_id("username").send_keys("hrteacher")
#输入用户名
driver.find_element_by_id("password").send_keys("123456")
#输入密码
driver.find_element_by_id("loginBtn").click()
#单击“登录”按钮
文前-04.indd 155 2021-11-11 12:01:53
Web 应用软件测试（中级） 
156
driver.find_element_by_link_text("人资工作台").click()
#通过link_text()方法定位页面元素，进入人资工作台页面

```

## partial_link_text定位

> 上面讲的link_text定位方法是找到超链接文本进行定位，有时一个超链接文本的字符串可能比较长，如果输入全称，会显示很长，占用编写脚本地方，而且不好看，这时可以用partial_link_text定位。这是一种模糊匹配方式，只要截取超链接文本中一部分字符串即可。
> 以人力资源综合服务系统中的人资工作台按钮为例，右击查看元素，如图所示。从图中可以看出，当要通过“人资工作台”进行定位的时候，只需输入“工作台”即可。格式：find_element_by_partial_link_text("")

![image-20221026100133687](https://raw.githubusercontent.com/azwwz/halo-synology-picture1/master/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/image-20221026100133687.png)

```python
实例：
（1）进入人力资源综合服务系统登录页面；
（2）输入用户名和密码；
（3）单击“登录”按钮；
（4）单击“人资工作台”按钮。
在PyCharm中进行代码编写：
from selenium import webdriver
driver=webdriver.Chrome()
driver.get("http://192.168.X.XXX/suthr/logon")
#进入人力资源综合服务系统登录页面
driver.find_element_by_id("username").send_keys("hrteacher")
#输入用户名
driver.find_element_by_id("password").send_keys("123456")
#输入密码
driver.find_element_by_id("loginBtn").click()
#单击“登录”按钮
driver.find_element_by_partial_link_text("工作台").click()
#通过partial_link_text()方法定位页面元素，进入人资工作台页面

```

## class_name定位

> 在编写自动化脚本的时候，如果某个页面元素既没有id属性，也没有name属性，但可以在定位的页面中找到class=""元素，那么就可以使用class_name元素实现定位。
> 以人力资源综合服务系统页面左侧的“培训进修”按钮为例，右击查看元素，如图所示。从图中定位到的元素属性可以看到有个class属性：class="icon-badge"，这里可以通过它的class属性定位到这个元素。格式：find_element_by_class_name("")

![image-20221026100209167](https://raw.githubusercontent.com/azwwz/halo-synology-picture1/master/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/image-20221026100209167.png)

```python
实例：
（1）进入人力资源综合服务系统登录页面；
（2）输入用户名和密码；
（3）单击“登录”按钮；
（4）单击页面左侧的“培训进修”按钮。
在PyCharm中进行代码编写：
from selenium import webdriver
driver=webdriver.Chrome()
driver.get("http://192.168.X.XXX/suthr/logon")
#进入人力资源综合服务系统登录页面
driver.find_element_by_name("username").send_keys("hrteacher")
#输入用户名
driver.find_element_by_name("password").send_keys("123456")
#输入密码
driver.find_element_by_id("loginBtn").click()
#单击“登录”按钮
driver.find_element_by_class_name("icon-badge").click()
#通过class_name()方法定位页面元素，进入培训进修页面

```

> 特殊情况：在HTML脚本中，会出现class属性中出现空格的情况，如图所示。
> 对于这种出现空格的情况，实际上是class属性中出现多个名字，空格前面一个名字，空格后面一个名字，在定位的时候用哪个名字都可以。

![image-20221026100253396](https://raw.githubusercontent.com/azwwz/halo-synology-picture1/master/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/image-20221026100253396.png)

```python
实例2：
（1）进入人力资源综合服务系统登录页面；
（2）输入用户名。
在PyCharm中进行代码编写：
from selenium import webdriver
driver=webdriver.Chrome()
driver.get("http://192.168.X.XXX/suthr/logon")
#进入人力资源综合服务系统登录页面
driver.find_element_by_class_name("form-control").send_keys("hrteacher")
#输入用户名

```

## tag_name定位

> HTML的本质就是通过tag来定义实现不同的功能，每一个元素本质上也是一个tag。tag往往用来定义一类功能，所以通过tag识别某个元素的概率很低，因此用得比较少。例如，页面中存在大量的<div>、<input>、<a>等tag。
> 以人力资源综合服务系统登录页面的“登录”按钮为例，先打开人力资源系统登录页面，选择“登录”按钮，右击查看元素，如图所示。从图中定位到的元素属性可以看到有个area属性：<button type="submit" class="submit_btn"style="">登录</button>，area是页面中独一无二的元素，这里可以通过它的area属性定位到这个元素。

![image-20221026100331104](https://raw.githubusercontent.com/azwwz/halo-synology-picture1/master/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/image-20221026100331104.png)

```python
实例：
（1）进入人力资源综合服务系统登录页面；
（2）单击“登录”按钮。
在PyCharm中进行代码编写：
from selenium import webdriver
driver=webdriver.Chrome()
driver.get("http://192.168.X.XXX/suthr/logon")
#进入人力资源综合服务系统登录页面
driver.find_element_by_tag_name("button").click()
#单击“登录”按钮

```

# 复数元素定位

> 八种基本定位方式对应的复数形式如下：
> ●　id复数定位find_elements_by_id( )；
> ●　name复数定位find_elements_by_name( )；
> ●　class复数定位find_elements_by_class_name( )；
> ●　tag复数定位find_elements_by_tag_name( )；
> ●　link复数定位find_elements_by_link_text( )；
> ●　partial_link复数定位find_elements_by_partial_link_text( )；
> ●　xpath复数定位find_elements_by_xpath( )；
> ●　css复数定位find_elements_by_css_selector( )。

> 这些复数定位方式每次取到的都是具有相同类型属性的一组元素，所以返回的是一个list队列，也可以利用这个队列去定位单个元素。
> 以人力资源综合服务系统登录页面为例，如图所示。	从图中我们可以看出，用户名输入框和密码输入框都有共同的标签input。定位到的元素属性中可以看到用户名输入框在页面排第一个，通过复数定位的代码为：driver.find_elements_by_tag_name("input")[0].send_keys("hrteacher")

![image-20221026100504713](https://raw.githubusercontent.com/azwwz/halo-synology-picture1/master/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/image-20221026100504713.png)

```python
实例：
（1）进入人力资源综合服务系统登录页面；
（2）输入用户名；
（3）输入密码。
在PyCharm中进行代码编写：
from selenium import webdriver
driver=webdriver.Chrome()
driver.get("http://192.168.X.XXX/suthr/logon")
#进入人力资源综合服务系统登录页面
driver.find_elements_by_tag_name("input")[0].send_keys("hrteacher")
#通过driver.find_elements_by_tag_name定位页面元素，输入用户名
driver.find_elements_by_tag_name("input")[1].send_keys("123456")
#通过driver.find_elements_by_tag_name定位页面元素，输入密码

```

# 鼠标操作

> ActionChains基本能够满足所有对鼠标操作的需求。使用此类中的方法时，需要先引入此类，引入代码为：selenium.webdriver.common.action_chains.ActionChains(driver)
> 需要了解ActionChains的执行原理，当调用ActionChains( )方法时，不会立即执行，而是会将所有的操作按顺序存放在一个队列里，当调用perform( )方法时，按照队列里面的顺序进行执行。其中调用的perform( )方法必须放在ActionChains方法最后。
> 这种情况下可以有两种调用方法，两种写法本质是一样的，ActionChains都会按照顺序执行所有的操作。

```python
1．链式写法
menu=driver.find_element_by_css_selector(".nav")
hidden_submenu=driver.find_element_by_css_selector(".nav #submenu1")
ActionChains(driver).move_to_element(menu).click(hidden_submenu).perform()
```

```python
2．分步写法
menu=driver.find_element_by_css_selector(".nav")
hidden_submenu=driver.find_element_by_css_selector(".nav #submenu1")
actions=ActionChains(driver)
actions.move_to_element(menu)
actions.click(hidden_submenu)
actions.perform()

```

# 键盘操作

> Keys基本能够满足对键盘基本操作的需求。模拟键盘的操作需要先引入键盘模块，引入脚本为：
> from selenium.webdriver.common.keys import Keys
> 在使用Keys方法时，可以分为两大类：

```python
（1）先使用ActionChains类将鼠标移动到需要进行键盘操作的位置，然后进行键盘操作，如以下代码：
ActionChains(driver).send_keys(Keys.TAB).send_keys(Keys.ENTER).perform()
#对定位到的元素进行回车操作

```

```python
（2）先通过元素定位方式进行元素定位，然后通过send_keys()进行键盘操作，如以下代码：
driver.find_element_by_id("kw").send_keys(Keys.ENTER)
#模拟Enter键操作回车按钮

```

> Keys方法列表如表所示。

![image-20221026100726333](https://raw.githubusercontent.com/azwwz/halo-synology-picture1/master/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/image-20221026100726333.png)

```python
实例：
（1）进入人力资源综合服务系统登录页面；
（2）输入用户名和密码，单击“登录”按钮；
（3）单击系统页面中的“培训进修”按钮；
（4）在培训内容输入框中输入信息dd；
（5）全选信息；
（6）复制信息；
（7）粘贴信息两次；
（8）过鼠标的形式单击“查询”按钮。
在PyCharm中进行代码编写：

import time
from selenium import webdriver
from selenium.webdriver import ActionChains
from selenium.webdriver.common.keys import Keys
driver=webdriver.Chrome()
driver.get("http://192.168.X.XXX/suthr/logon")#进入人力资源综合服务系统登录页面
driver.find_element_by_name("username").send_keys("hrteacher")#输入用户名
driver.find_element_by_name("password").send_keys("123456")#输入密码
driver.find_element_by_class_name("uppercase").click()#单击“登录”按钮
driver.find_element_by_link_text("培训进修").click()#单击“培训进修”按钮
driver.find_element_by_id("content").send_keys("dd")#在培训内容输入框输入信息
time.sleep(3)
driver.find_element_by_id("content").send_keys(Keys.CONTROL,'a')
time.sleep(3)#全选信息
driver.find_element_by_id("content").send_keys(Keys.CONTROL,'c')
time.sleep(3)#复制信息
driver.find_element_by_id("content").send_keys(Keys.CONTROL,'v')
time.sleep(3)#粘贴信息
driver.find_element_by_id("content").send_keys(Keys.CONTROL,'v')
time.sleep(3)#粘贴信息
ActionChains(driver).send_keys(Keys.TAB).send_keys(Keys.TAB).send_keys(Keys.
TAB).send_keys(Keys.ENTER).perform()#单击“查询”按钮

```

# 时间等待方法

> 测试过程中，会发现脚本执行的时候展现出来的效果都是很快结束，此时可以增加一个等待时间来观察执行效果。这种等待时间只是为了便于观察，这种情况下是否包含等待时间不会影响执行结果，但是有一种情况会直接影响执行结果。在打开一个网站的时候，由于环境的因素导致页面没有加载完成，此时去定位元素无法找到元素，这种情况下增加等待时间就会显得万分重要。本任务针对时间等待处理进行介绍。

> Selenium主要提供WebDriverWait和Implicit Wait两种模式的等待，但是Python time模块也提供一种非智能的sleep( )等待，使用这个设置以后必须强制等待设置的时间，只有等待时间结束才会继续执行。这种模式一般会用于观察执行效果的时候，而WebDriverWait和Implicit Wait这两种时间等待属于智能等待。

## 显式等待

例如：element=WebDriverWait(driver,10).until(lambda x: x.find_element_by_id("someId"))
is_disappeared=WebDriverWait(driver,30,1,(ElementNotVisibleException)).
until_not(lambda x: x.find_element_by_id("someId").is_displayed())
注意：until是固定格式，可以理解为直到元素定位到为止；lambda x:x是一个匿名函数构建的方法，这里不太好理解，可以理解为固定格式，最后接定位方法。

```python
例如：element=WebDriverWait(driver,10).until(lambda x: x.find_element_by_id("someId"))
is_disappeared=WebDriverWait(driver,30,1,(ElementNotVisibleException)).
until_not(lambda x: x.find_element_by_id("someId").is_displayed())
注意：until是固定格式，可以理解为直到元素定位到为止；lambda x:x是一个匿名函数构建的方法，这里不太好理解，可以理解为固定格式，最后接定位方法。

```

`WebDriverWait( )`一般由`unit( )`或`until_not( )`方法配合使用。
●　`until(method, message='')`调用该方法提供的驱动程序作为一个参数，直到返回值不为False；
●　`until_not(method, message='')`调用该方法提供的驱动程序作为一个参数，直到返回值为False。

```python
实例1：
（1）进入人力资源综合服务系统登录页面；
（2）输入用户名和密码；
（3）单击“登录”按钮，设置时间等待。
在PyCharm中进行代码编写：
from selenium import webdriver
from selenium.webdriver.support.wait import WebDriverWait
driver=webdriver.Chrome()
driver.get("http://192.168.X.XXX/suthr/logon")
#进入人力资源综合服务系统登录页面
driver.find_element_by_name("username").send_keys("hrteacher")
#输入用户名
driver.find_element_by_name("password").send_keys("123456")
#输入密码
element=WebDriverWait(driver,10).until(lambda x:x.find_element_by_id("loginBtn"))
#定位“登录”按钮并设置时间等待
element.click()
#单击“登录”按钮

```

## 强制等待

设置等待最简单的方法就是强制等待，也就是sleep( )方法。它可以让程序暂停运行一定时间，时间过后继续运行。其缺点是不智能，如果设置的时间太短，元素还没有加载出来，则照样会报错；如果设置的时间太长，则会浪费时间。如果代码量过大，多个强制等待会影响整体的运行速度。
	使用强制等待sleep( )需要导入sleep。代码如下：`from time import sleep`。使用格式：sleep()

```python
实例2：
（1）进入人力资源综合服务系统登录页面；
（2）输入用户名和密码，设置时间等待；
（3）单击“登录”按钮。
在PyCharm中进行代码编写：
from time import sleep
from selenium import webdriver
driver=webdriver.Chrome()
driver.get("http://192.168.X.XXX/suthr/logon")
#进入人力资源综合服务系统登录页面
driver.find_element_by_name("username").send_keys("hrteacher")
#输入用户名
driver.find_element_by_name("password").send_keys("123456")
#输入密码
sleep(5)
#时间等待
driver.find_element_by_class_name("uppercase").click()
#单击“登录”按钮

```

## 隐式等待

隐性等待就是设置一个等待时间范围，这个等待时间是不固定的，最长的等待时间是设置的最大值。隐性等待也称智能等待，是Selenium提供的一个超时等待。它等待一个元素被发现，或一个命令完成，如果超出设置时间则抛出异常。
	使用格式：driver.implicitly_wait()

```python
实例3：
（1）进入人力资源综合服务系统登录页面，设置时间等待；
（2）输入用户名和密码；
（3）单击“登录”按钮。
在PyCharm中进行代码编写：
from selenium import webdriver
driver=webdriver.Chrome()
driver.get("http://192.168.X.XXX/suthr/logon")
#进入人力资源综合服务系统登录页面
driver.implicitly_wait(30)
#时间等待
driver.find_element_by_name("username").send_keys("hrteacher")
#输入用户名
driver.find_element_by_name("password").send_keys("123456")
#输入密码
driver.find_element_by_class_name("uppercase").click()
#单击“登录”按钮

```

# 窗口切换

有些页面的链接打开后会重新打开一个窗口，想在新页面上操作就得先切换窗口。获取窗口的唯一标识用句柄表示，所以只需要切换句柄，就能在多个页面上灵活操作。本任务针对窗口切换进行介绍。
以人力资源综合服务系统为例，单击门户首页，在门户首页中单击“论坛”按钮，发现右侧多出一个窗口标签，如图所示。

![image-20221026104123086](https://raw.githubusercontent.com/azwwz/halo-synology-picture1/master/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/image-20221026104123086.png)

元素有属性，浏览器的窗口也有属性，浏览器窗口的属性可以用脚本(handle)来识别。对于初学者来说，可以将窗口切换分为四步进行：（1）获取第一个窗口的名字，代码为：`print(driver.current_window_handle)`

（2）获取所有窗口的名字，代码为：`print(driver.window_handles)`

（3）获取到第二个窗口的名字，代码为：`print(driver.window_handles[1])`

（4）进行窗口切换，代码为：`driver.switch_to.window(driver.window_handles[1])`

```python
实例：
（1）进入人力资源综合服务系统登录页面；
（2）输入用户名和密码，单击“登录”按钮；
（3）单击页面上面的“人资工作台”按钮；
（4）单击页面左侧的“论坛后台管理”按钮；
（5）单击“举报处理”按钮；
（6）单击“回帖举报”按钮；
（7）单击回帖举报页面中的“举报流水”按钮；
（8）关闭新弹出的标签页。
在PyCharm中进行代码编写：
import time
from selenium import webdriver
driver=webdriver.Chrome()
driver.get("http://192.168.X.XXX/suthr/logon")#进入人力资源综合服务系统登录页面
driver.implicitly_wait(30)
driver.find_element_by_name("username").send_keys("hrteacher")#输入用户名
driver.find_element_by_name("password").send_keys("123456")#输入密码
driver.find_element_by_class_name("uppercase").click()#单击“登录”按钮
driver.find_element_by_link_text("人资工作台").click()#单击“人资工作台”按钮
driver.find_element_by_link_text("论坛后台管理").click()#单击“论坛后台管理”按钮
driver.find_element_by_link_text("举报处理").click()#单击“举报处理”按钮
driver.find_element_by_link_text("回帖举报").click()#单击“回帖举报”按钮
driver.find_element_by_xpath("/html/body/div[4]/div[2]/div/div[2]/div/div/div[2]
/div[2]/table/tbody/tr[1]/td[10]/a[1]").click()#单击“举报流水”按钮
print(driver.current_window_handle)# 获取第一个窗口的名字
print(driver.window_handles)# 获取所有窗口的名字
print(driver.window_handles[1])# 获取到第二个窗口的名字,Window_handle[1]用到数组的原理
driver.switch_to.window(driver.window_handles[1])#进行窗口切换
time.sleep(5)
driver.close()

```

# 页面元素删除

对于单击某个链接后是否弹出新窗口，可以通过图1和图2所示的HTML代码进行比较。通过观察两个窗口中页面HTML代码的区别，以及通过删除弹出新窗口中的某个属性后，再次单击弹出新窗口的超链接，得出的结论是有target属性就会弹出新的窗口。
要想让链接不弹出新窗口，只需在代码执行时删除target属性即可。

![image-20221026104226339](https://raw.githubusercontent.com/azwwz/halo-synology-picture1/master/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/image-20221026104226339.png)

![image-20221026104245875](https://raw.githubusercontent.com/azwwz/halo-synology-picture1/master/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/image-20221026104245875.png)

target属性删除步骤（以人力资源综合服务系统门户首页中的论坛按钮为例）：

（1）用Selenium定位“目标”链接：`login_link=driver.find_element_by_XX("目标")`；

（2）删除已找到的页面元素的target属性：`driver.execute_script("arguments[0].removeAttribute('target')",login_link)`，其中`arguments[0]`的意思就是去字符串后面的第一个参数`login_link`的真正的值；

（3）单击删除target属性后的页面元素：`login_link.click()`

```python
实例：
（1）进入人力资源综合服务系统登录页面；
（2）输入用户名和密码，单击“登录”按钮；
（3）单击人力资源服务系统页面的“人资工作台”按钮；
（4）在人资工作台页面单击左侧的“论坛后台管理”按钮；
（5）单击“主题及回帖管理”按钮；
（6）单击“回帖管理”按钮（要求不弹出新的标签页，在一个标签页中显示）。
在PyCharm中进行代码编写：
import time
from selenium import webdriver
driver=webdriver.Chrome()
driver.get("http://192.168.X.XXX/suthr/logon")#进入人力资源综合服务系统登录页面
driver.implicitly_wait(30)
driver.find_element_by_name("username").send_keys("hrteacher")#输入用户名
driver.find_element_by_name("password").send_keys("123456")#输入密码
driver.find_element_by_class_name("uppercase").click()
#单击“登录”按钮
driver.find_element_by_link_text("人资工作台").click()
#单击“人资工作台”按钮
driver.find_element_by_link_text("论坛后台管理").click()
#单击“论坛后台管理”按钮
driver.find_element_by_link_text("主题及回帖管理").click()
#单击“主题及回帖管理”按钮
element=driver.find_element_by_xpath("/html/body/div[4]/div[2]/div/div[2]/div/div/
div[2]/div[2]/table/tbody/tr[1]/td[10]/a[2]")
#用selenium定位回帖管理链接信息
driver.execute_script("arguments[0].removeAttribute('target')",element)
#删除已找到的回帖管理页面元素的targer属性
element.click()
#单击删除targer属性后，进入回帖管理页面

```

![image-20221027134238427](https://raw.githubusercontent.com/azwwz/halo-synology-picture1/master/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/image-20221027134238427.png)

# submit()方法使用

![image-20221026104351337](https://raw.githubusercontent.com/azwwz/halo-synology-picture1/master/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/image-20221026104351337.png)

```python
实例：
（1）进入人力资源综合服务系统登录页面；
（2）输入用户名和密码；
（3）单击“登录”按钮。
在PyCharm中进行代码编写：
import time
from selenium import webdriver
driver=webdriver.Chrome()
driver.get("http://192.168.X.XXX/suthr/logon")
#进入到人力资源综合服务系统登录页面
driver.find_element_by_name("username").send_keys("hrteacher")
#输入用户名
driver.find_element_by_name("password").send_keys("123456")
#输入密码
driver.find_element_by_id("loginBtn").submit()
#单击“登录”按钮

```

# 操作下拉滚动条

在Selenium中提供两种方法来处理拖动下拉滚动条的问题。

```python
1．通过连续按方向箭头的方法实现
根据鼠标和键盘的相关知识和操作命令，可以借助于鼠标和键盘的操作命令来实现下拉滚动条的移动。例如，进入某个页面后存在下拉滚动条，且能够移动，则可以通过鼠标和键盘的操作命令找到隐藏的文字进行超链接，代码如下：
ActionChains(driver).send_keys(Keys.ARROW_DOWN).send_keys(Keys.ARROW_DOWN).
send_keys(Keys.ARROW_DOWN).perform()

```

```python
2．用 JavaScript 中的语句实现滚动条移动
JavaScript也是编写自动化脚本的一种语言，编写脚本的时候用得比较少，但是有的时候用JavaScript写的代码更加简单、实用。关于JavaScript的知识可以从网上进行简单学习。代码如下：
driver.execute_script("window.scrollTo(0,0)")
代码中的(0,0)代表页面横向和纵向的坐标。

```

比如，人力资源综合服务系统页面中的人资工作台页面左侧，需要进行拖动下拉条后才能看见页面最下面的文字，如图所示。

![image-20221026104458800](https://raw.githubusercontent.com/azwwz/halo-synology-picture1/master/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/image-20221026104458800.png)

```python
实例1：
（1）进入人力资源综合服务系统登录页面；操作下拉滚动条方法
（2）输入用户名和密码，单击“登录”按钮；
（3）单击“人资工作台”按钮，进入人资工作台页面；
（4）实现页面中滚动条的横向和纵向移动。
在PyCharm中进行代码编写：
from selenium import webdriver
from selenium.webdriver import ActionChains
from selenium.webdriver.common.keys import Keys
driver=webdriver.Chrome()
driver.get("http://192.168.X.XXX/suthr/logon")
#进入人力资源综合服务系统登录页面
driver.find_element_by_name("username").send_keys("hrteacher")
#输入用户名
driver.find_element_by_name("password").send_keys("123456")
#输入密码
driver.find_element_by_class_name("uppercase").click()
#单击“登录”按钮
driver.find_element_by_link_text("人资工作台").click()
#单击“人资工作台”按钮
ActionChains(driver).send_keys(Keys.ARROW_DOWN).send_keys(Keys.ARROW_DOWN).send_
keys(Keys.ARROW_DOWN).send_keys(Keys.ARROW_DOWN).send_keys(Keys.ARROW_DOWN).perform()
#滚动条移动

```
![image-20221026104458800](https://raw.githubusercontent.com/azwwz/halo-synology-picture1/master/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/image-20221026104458800.png)

```python
实例2：
（1）进入人力资源综合服务系统登录页面；操作下拉滚动条方法
（2）输入用户名和密码，单击“登录”按钮；
（3）单击“人资工作台”按钮，进入人资工作台页面；
（4）实现页面中滚动条的横向和纵向移动。
在PyCharm中进行代码编写：
from selenium import webdriver
driver=webdriver.Chrome()
driver.get("http://192.168.X.XXX/suthr/logon")
#进入人力资源综合服务系统登录页面
driver.find_element_by_name("username").send_keys("hrteacher")
#输入用户名
driver.find_element_by_name("password").send_keys("123456")
#输入密码
driver.find_element_by_class_name("uppercase").click()
#单击“登录”按钮
driver.find_element_by_link_text("人资工作台").click()
#单击“人资工作台”按钮
driver.execute_script("window.scrollTo(0,400)")
#滚动条移动

```

# 下拉框处理

对于图1图2所示问题，可以用三种方法进行元素定位。

![image-20221026104728402](https://raw.githubusercontent.com/azwwz/halo-synology-picture1/master/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/image-20221026104728402.png)

![image-20221026104737793](https://raw.githubusercontent.com/azwwz/halo-synology-picture1/master/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/image-20221026104737793.png)

## 使用选项元素标签定位

`实例1：
（1）进入人力资源综合服务系统登录页面；
（2）输入用户名和密码，单击“登录”按钮；
（3）单击人力资源服务系统页面中的“人资工作台”按钮；
（4）单击人资工作台页面左侧的“员工基本信息管理”按钮；
（5）单击“员工信息管理”按钮；
（6）在员工信息管理页面选择政治面貌为其他。
在PyCharm中进行代码编写：`

```python
import time
from selenium import webdriver
from selenium.webdriver import ActionChains
driver=webdriver.Chrome()
driver.get("http://192.168.X.XXX/suthr/logon")
#进入人力资源综合服务系统登录页面
driver.implicitly_wait(30)
driver.find_element_by_name("username").send_keys("hrteacher")
#输入用户名
driver.find_element_by_name("password").send_keys("123456")
#输入密码
driver.find_element_by_class_name("uppercase").click()
#单击“登录”按钮
driver.find_element_by_link_text("人资工作台").click()
#单击“人资工作台”按钮
element=driver.find_element_by_link_text("员工基本信息管理")
#定位“员工基本信息管理”按钮
ActionChains(driver).click(element).perform()
#单击“员工基本信息管理”按钮
driver.find_element_by_link_text("员工信息管理").click()
#单击“员工信息管理”按钮
driver.find_elements_by_tag_name("select")[1].click()
#单击select标签
driver.find_elements_by_tag_name("option")[8].click()
#选择政治面貌并单击

```

## 直接通过xpath层级标签定位

`实例2：
（1）进入人力资源综合服务系统登录页面；
（2）输入用户名和密码，单击“登录”按钮；
（3）单击人力资源服务系统页面中的“人资工作台”按钮；
（4）单击人资工作台页面左侧的“员工基本信息管理”按钮；
（5）单击“员工信息管理”按钮；
（6）在员工信息管理页面选择政治面貌为其他。
在PyCharm中进行代码编写：`

```python
import time
from selenium import webdriver
from selenium.webdriver import ActionChains
driver=webdriver.Chrome()
driver.get("http://192.168.X.XXX/suthr/logon")
#进入人力资源综合服务系统登录页面
driver.implicitly_wait(30)
driver.find_element_by_name("username").send_keys("hrteacher")
#输入用户名
driver.find_element_by_name("password").send_keys("123456")
#输入密码
driver.find_element_by_class_name("uppercase").click()
#单击“登录”按钮
driver.find_element_by_link_text("人资工作台").click()
#单击“人资工作台”按钮
element=driver.find_element_by_link_text("员工基本信息管理")
#定位“员工基本信息管理”按钮
ActionChains(driver).click(element).perform()
#单击“员工基本信息管理”按钮
driver.find_element_by_link_text("员工信息管理").click()
#单击“员工信息管理”按钮
driver.find_element_by_xpath("/html/body/div[4]/div[2]/div/div[2]/div[2]/div/
div/form/div/div[1]/div/div[3]/select/option[6]").click()
#选择政治面貌并单击

```

## 导入Select模块

使用Select模块的方法除上面介绍的方法外，Selenium还提供了更高级的方法，即导入Select模块，直接根据属性或索引定位。
（1）导入Select模块方法：from selenium.webdriver.support.select import Select;
（2）通过select选项的名称定位选择对应选项，如选择其他选项，使用如下命令：select_by_visible_text("其他")

`实例3：
（1）进入人力资源综合服务系统登录页面；
（2）输入用户名和密码，单击“登录”按钮；
（3）单击人力资源服务系统页面中的“人资工作台”按钮；
（4）单击人资工作台页面左侧的“员工基本信息管理”按钮；
（5）单击“员工信息管理”按钮；
（6）在员工信息管理页面选择政治面貌为其他。
在PyCharm中进行代码编写：`

```python
import time
from selenium import webdriver
from selenium.webdriver import ActionChains
from selenium.webdriver.support.select import Select
driver=webdriver.Chrome()
driver.get("http://192.168.X.XXX/suthr/logon")
#进入人力资源综合服务系统登录页面
driver.implicitly_wait(30)
driver.find_element_by_name("username").send_keys("hrteacher")#输入用户名
driver.find_element_by_name("password").send_keys("123456")#输入密码
driver.find_element_by_class_name("uppercase").click()
#单击“登录”按钮
driver.find_element_by_link_text("人资工作台").click()
#单击“人资工作台”按钮
element=driver.find_element_by_link_text("员工基本信息管理")
#定位“员工基本信息管理”按钮
ActionChains(driver).click(element).perform()
#单击“员工基本信息管理”按钮
driver.find_element_by_link_text("员工信息管理").click()
#单击“员工信息管理”按钮
select=driver.find_element_by_id("dictPoliticalStatus")
#定位下拉框
Select(select).select_by_visible_text("其他")
#定位下拉框选项

```

`实例4：
（1）进入人力资源综合服务系统登录页面；
（2）输入用户名和密码，单击“登录”按钮；
（3）单击人力资源服务系统页面中的“人资工作台”按钮；
（4）单击人资工作台页面左侧的“员工基本信息管理”按钮；
（5）单击“员工信息管理”按钮；
（6）在员工信息管理页面选择政治面貌为其他。
在PyCharm中进行代码编写：`

```python
import time
from selenium import webdriver
from selenium.webdriver import ActionChains
from selenium.webdriver.support.select import Select
driver=webdriver.Chrome()
driver.get("http://192.168.1.228/suthr/logon")#进入人力资源综合服务系统登录页面
driver.implicitly_wait(30)
driver.find_element_by_name("username").send_keys("hrteacher")#输入用户名
driver.find_element_by_name("password").send_keys("123456")
#输入密码
driver.find_element_by_class_name("uppercase").click()
#单击“登录”按钮
driver.find_element_by_link_text("人资工作台").click()
#单击“人资工作台”按钮
element=driver.find_element_by_link_text("员工基本信息管理")
#定位“员工基本信息管理”按钮
ActionChains(driver).click(element).perform()
#单击“员工基本信息管理”按钮
driver.find_element_by_link_text("员工信息管理").click()
#单击“员工信息管理”按钮
select=driver.find_element_by_id("dictPoliticalStatus")
#定位下拉框
Select(select).select_by_value("261")
#定位下拉框选项

```

## csdn查到的

### 下拉框选项操作：Select

------

 

**针对下拉框选项，可以直接获取下拉框中的值，然后再循环获取匹配，也可以直接通过元素定位直接操作。**

**针对select/option这样下拉选择框，如图展示：![img](https://raw.githubusercontent.com/azwwz/halo-synology-picture1/master/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/20210312190450849.png)，我们可以直接使用webdriver中的\**Select\**类去处理 。**

 

**首先是引入\**Select\**类(两种引包方法)：**

```python
from selenium.webdriver.support.select import Select
from selenium.webdriver.support.ui import Select
```

**ui.py文件中实际引入的也是 select下的\**Select\**类，所以我们引入ui包实际引入的还是\**Select\**类：**

![img](https://raw.githubusercontent.com/azwwz/halo-synology-picture1/master/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xJRkVORzA0MDI=,size_16,color_FFFFFF,t_70.png)

**源码中\**Select\**下有很多方法，专门用于处理下拉选择框操作：**

![img](https://raw.githubusercontent.com/azwwz/halo-synology-picture1/master/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xJRkVORzA0MDI=,size_16,color_FFFFFF,t_70-16668556110361.png)

 

- ### options：返回属于该选择标签的所有选项列表

```python
from selenium import webdriver
from selenium.webdriver.support.select import Select
from selenium.webdriver.common.by import By
driver = webdriver.Chrome()
driver.get('https://www.w3school.com.cn/tiy/t.asp?f=html_select')
driver.find_element_by_xpath("//a[contains(text(),'运行代码')]").click()
iframeResult = driver.find_element_by_xpath("//iframe[@id='iframeResult']")
driver.switch_to.frame(iframeResult)
result = Select(driver.find_element(By.CSS_SELECTOR, "body:nth-child(2) > select:nth-child(1)")).options
for i in result:
    print(i.text)
```

 运行后的结果：下拉选择框中的数据循环打印显示在控制台

```python
F:\virtualEnvironment\venv\Scripts\python.exe F:/git/AuomationTest/AuomationTestProject/webTestAuomation/selenium_select.py
Volvo
Saab
Opel
Audi

Process finished with exit code 0
```

- ### all_selected_options：返回属于此选择标签的所有选择的选项列表

```python
result = Select(driver.find_element(By.CSS_SELECTOR, "body:nth-child(2) > select:nth-child(1)")).all_selected_options
for i in result:
    print(i.text)
driver.quit()
```

 运行后的结果：下拉选择框中循环打印被选中的的选项

```python
F:\virtualEnvironment\venv\Scripts\python.exe F:/git/AuomationTest/AuomationTestProject/webTestAuomation/selenium_select.py
Volvo

Process finished with exit code 0 
```

- ### first_selected_option：该选择标签中的第一个选择的选项（或正常选择中当前选择的选项）

```python
result = Select(driver.find_element(By.CSS_SELECTOR, "body:nth-child(2) > select:nth-child(1)")).first_selected_option
print(result.text)
driver.quit() 
```

 运行后的结果：打印下拉框中第一个被选中的的选项

```python
F:\virtualEnvironment\venv\Scripts\python.exe F:/git/AuomationTest/AuomationTestProject/webTestAuomation/selenium_select.py
Volvo

Process finished with exit code 0
```

 

------


**下面示例html代码：**

```html
<!DOCTYPE html>
<html>
<body>
<select>
  <option value="volvo">Volvo</option>
  <option value="saab">Saab</option>
  <option value="opel">Opel</option>
  <option value="audi">Audi</option>
</select>
</body>
</html>
```

 

- ### select_by_value：选择所有值都与参数匹配的选项。

  例如： select_by_value("volvo")，选择的就是第一个：" <option value="volvo">Volvo</option> "

 

- ### select_by_index：选择给定索引处的选项。这是通过检查元素的“索引”属性来完成的。

  例如：select_by_index(1)，选择的就是第二个：" <option value="saab">Saab</option> "

 

- ### select_by_visible_text：选择所有显示与参数匹配的文本的选项。

  例如：图片标蓝框处的文本信息 ![img](https://raw.githubusercontent.com/azwwz/halo-synology-picture1/master/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/20210312182917162.png)，select_by_visible_text("Audi")，选择的就是第四个：" <option value="audi">Audi</option> "

 

**下面示例代码，仅供参考：**

```python
result = Select(driver.find_element(By.CSS_SELECTOR, "body:nth-child(2) > select:nth-child(1)"))
result.select_by_index(1)
for i in result.all_selected_options:
    print(i.text)
result.select_by_value("opel")
for i in result.all_selected_options:
    print(i.text)
result.select_by_visible_text("Audi")
for i in result.all_selected_options:
    print(i.text)
time.sleep(10)
driver.quit()
```

  运行后的结果：每一个获到参数的方法全部都做了循环并打印到控制台

```python
F:\virtualEnvironment\venv\Scripts\python.exe F:/git/AuomationTest/AuomationTestProject/webTestAuomation/selenium_select.py
Saab
Opel
Audi

Process finished with exit code 0
```

-  deselect_all：清除所有选定的条目。这仅在SELECT支持多个选择时才有效。

-  deselect_by_value：取消选择所有值都与参数匹配的选项。

-  deselect_by_index：取消选择给定索引处的选项。

-  deselect_by_visible_text：取消选择所有显示与参数匹配的文本的选项。

```python
result = Select(driver.find_element(By.CSS_SELECTOR, "body:nth-child(2) > select:nth-child(1)"))
result.deselect_by_index(1)
result.deselect_by_value("opel")
result.deselect_by_visible_text("Audi")
result.deselect_all()
time.sleep(10)
driver.quit()
```

**\deselect_xxxxxxx\开头的方法，就是取消选中操作的意思，如果没有指定值存在就会抛异常：**NotImplementedError， **取消的方法其实就是跟选中的方法一样操作，无非就是先选中后再进行取消操作，在此就不再多作叙述，可自行实操下效果...**

# 文件上传处理

在实现UI自动化测试过程中，文件上传操作也是常见功能之一。对于文件上传功能并没有用到新方法或函数，关键是思路。上传过程一般要打开一个本地窗口，然后从窗口选择本地文件添加。
在Selenium webdriver中文件上传并不复杂，只要定位“上传”按钮，找到input标签属性，如<input type="file" name="filename">，然后通send_keys添加本地文件路径即可。

![image-20221026105024607](https://raw.githubusercontent.com/azwwz/halo-synology-picture1/master/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/image-20221026105024607.png)

![image-20221026105057491](https://raw.githubusercontent.com/azwwz/halo-synology-picture1/master/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/image-20221026105057491.png)

文件上传处理方法使用

`实例：
（1）进入人力资源综合服务系统登录页面；
（2）输入用户名和密码，单击“登录”按钮；
（3）在人力资源服务系统页面单击“人资工作台”按钮；
（4）在人资工作台页面单击左侧的“员工基本信息管理”按钮；
（5）单击“员工照片管理”按钮；
（6）在员工照片管理页面中单击“编辑”按钮，打开编辑页面；
（7）在编辑页面中单击“选择本地文件”按钮，上传文件。
在PyCharm中进行代码编写：`

```python
import time
from selenium import webdriver
from selenium.webdriver import ActionChains
driver=webdriver.Chrome()
driver.get("http://192.168.X.XXX/suthr/logon")#进入人力资源综合服务系统登录页面
driver.implicitly_wait(30)
driver.find_element_by_name("username").send_keys("hrteacher")#输入用户名
driver.find_element_by_name("password").send_keys("123456")#输入密码
driver.find_element_by_class_name("upp ercase").click()
#单击“登录”按钮
driver.find_element_by_link_text("人资工作台").click()
#单击“人资工作台”按钮
a=driver.find_element_by_link_text("员工基本信息管理")
#定位“员工基本信息管理”按钮
ActionChains(driver).click(a).perform()
#单击“员工基本信息管理”按钮
driver.find_element_by_link_text("员工照片管理").click()
#单击“员工照片管理”按钮
driver.find_element_by_xpath("/html/body/div[4]/div[2]/div/div[2]/div/div/div/
div[2]/table/tbody/tr[1]/td[9]/a").click()
#单击“编辑”按钮
driver.find_element_by_name("file").send_keys(r"C:\Users\Public\Pictures\Sample 
Pictures\juehua.jpg")
#上传文件处理

```

# 页面截图操作

截图方法：`get_screenshot_as_file(self, filename)`
代码如下：`driver.get_screenshot_as_file(r"路径名\图片名字")`

`实例：
（1）进入人力资源综合服务系统登录页面；
（2）对登录页面进行截图操作。
在PyCharm中进行代码编写：`

```python
from selenium import webdriver
driver=webdriver.Chrome()
driver.get("http://192.168.X.XXX/suthr/logo")
#进入人力资源综合服务系统登录页面
driver.get_screenshot_as_file(r"C:\Users\Public\Pictures\Sample Pictures\denglu.png")
#截图操作
```

# alert对话框处理

当登录某些界面的时候，输入用户名和密码错误，会弹出一个alert（警告）对话框，如果不关闭该对话框就没法继续执行下去，所以无法通过定位的方式定位它的位置。
弹出对话框主要分为三种类型：“警告对话框”“确认对话框”，“提示对话框”。

![image-20221026105515248](https://raw.githubusercontent.com/azwwz/halo-synology-picture1/master/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/image-20221026105515248.png)

1．警告对话框：警告对话框提供一个“确定”按钮让用户关闭该对话框，而且该对话框是模式对话框，也就是说，用户必须先关闭该对话框然后才能继续进行操作。
2．确认对话框：确认对话框向用户提示一个“是与否”问题，用户可以根据单击“确定”按钮和“取消”按钮。
3．提示对话框：提示对话框提供一个文本字段，用户可以在此字段输入一个答案来响应提示。有一个“确定”按钮和“取消”按钮。单击“确认”按钮会响应对应的提示信息，单击“取消”按钮会关闭对话框。
Selenium提供switch_to_alert( )方法定位到alert/confirm/prompt对话框。使用text/accept/dismiss/send_keys进行操作，需要注意的是send_keys只能对prompt操作，因为只有它是要输入内容的。
text/accept/dismiss/send_keys所代表的意思：
●　text( )#获取对话框文本值；
●　accept( )#相当于单击“确认”按钮；
●　dismiss( )#相当于单击“取消”按钮；
●　send_keys( )#输入值，这个alter和confirm没有输入对话框，所以这里不能用，只能用于prompt。

```python
例如，接受对话框：
element=driver.switch_to_alert()
element.accept()

```

```python
例如，得到对话框的文本消息，比如得到“请输入用户名”。
element=driver.switch_to_alert().text
print(element)
```

```python
例如，“取消”按钮：
element=driver.switch_to_alert()
element.dismiss()
```

```python
例如，输入值：
element=driver.switch_to_alert()
element.send_keys("hello")
```

alert对话框处理方法使用

`实例：
（1）进入人力资源综合服务系统登录页面；
（2）输入用户名和密码，单击“登录”按钮；
（3）单击人力资源综合服务系统页面中的“门户首页”按钮；
（4）单击门户首页中的“论坛”按钮（始终在一个标签页中运行）；
（5）单击论坛首页中的某个热门主题信息；
（6）单击热门主题信息页面中最下面的“回复”按钮；
（7）打印弹出警告对话框中的文字信息，并关闭警告对话框。
在PyCharm中进行代码编写：`

```python
import time
from selenium import webdriver
from selenium.webdriver import ActionChains
driver=webdriver.Chrome()
driver.get("http://192.168.X.XXX/suthr/logo")#进入人力资源综合服务系统登录页面
driver.implicitly_wait(30)
driver.find_element_by_name("username").send_keys("hrteacher")#输入用户名
driver.find_element_by_name("password").send_keys("123456")#输入密码
driver.find_element_by_class_name("btn-success").click()#单击“登录”按钮
driver.find_element_by_link_text("门户首页").click()#单击“门户首页”按钮
a=driver.find_element_by_xpath("/html/body/div[3]/div[1]/div/div/div/div[2]/div[2]/div/a")
driver.execute_script("arguments[0].removeAttribute('target')",a)
a.click()#单击“论坛”按钮
driver.find_element_by_link_text("颠三倒四多").click()#单击热门主题信息
driver.execute_script("window.scrollTo(0,2000)")
b=driver.find_element_by_id("replyBtn")
ActionChains(driver).click(b).perform()#弹出警告对话框
time.sleep(5)
element=driver.switch_to_alert().text#打印弹出警告对话框文字
print(element)
driver.switch_to_alert().accept()#关闭警告对话框

```

# Unittest

## Unittest工作原理

Unittest最核心的是`TestCase、TestSuite、TestRunner、TestFixture`四部分。

- TestCase：用户自定义测试用例的基类，调用`run( )`方法时，会依次调用`setUp( )`方法、执行用例的方法、`tearDown( )`方法
- TestSuite：测试用例集合，可以通过`addTest( )`方法手动增加`TestCase`，也可以通过`TestLoader`自动添加`TestCase`，`TestLoader`在添加用例时没有顺序
- TestRunner：运行测试用例的驱动类，可以执行`TestCase`，也可以执行`TestSuite`，执行后`TestCase`和`TestSuite`会自动管理`TestResult`
- TestFixture：进行测试过程的准备活动，比如创建临时数据库、文件和目录等，其中`setUp( )`和`setDown( )`是最常用的方法

## Unittest方法使用

（1）写好`TestCase`：一个class继承`unittest.TestCase`，就是一个测试用例，其中有多个以`test`开头的方法，每个方法在`load`的时候会生成一个`TestCase`实例。如果一个`class`中有四个`test`开头的方法，则最后`load`到suite中时有四个测试用例。
（2）由`TestLoader`加载`TestCase`到`TestSuite`。
（3）由`TextTestRunner`运行`TestSuite`，运行结果保存在`TextTestResult`中。通过命令行或者`unittest.main( )`方法执行时，`main`会调用`TextTestRunner`中的`run()`方法来执行用例，或者可以直接通过`TextTestRunner`来执行用例。`Runner`执行时，默认将结果输出到控制台。可以设置其输出到文件，在文件中查看结果；也可以通过`HTMLTestRunne`r将结果输出到`HTML`。

## Unittest主要类关系

正常调用`Unittest`的流程是`TestLoader`自动将测试用例`TestCase`中加载到`TestSuite`里，`TextTestRunner`调用TestSuite的`run( )`方法，顺序执行其中的`TestCase`中以`test`开头的方法，并得到测试结`TestResult`。

在执行`TestCase`过程中，先通过`SetUp( )`方法进行环境准备，执行测试代码，最后通过`tearDown( )`方法进行测试的还原。

`TestLoader`在加载过程中进行添加的`TestCase`是没有顺序的。一个`TestCase`里如果存在多个验证方法，会按照方法中`test`后方首字母的`ASCII`码从小到大排序后执行。

可以通过手动调用`TestSuite`的`addTest( )`、`addTest( )`方法来动态添加`TestCase`，这样既可以确定添加用例的执行顺序，也可避免`TestCase`中的验证方法一定要用`test`开头。

## Unittest框架使用说明

（1）`import unittest` #导入测试框架：定义一个继承自`unittest.TestCase`的测试用例类。定义`setUp( )`方法、`tearDown( )`方法、`setUpClass( )`方法、`tearDownClass( )`方法。其中`setUp( )`方法指在每个测试用例方法执行前都会执行一次；`tearDown( )`方法指在每次测试用例方法执行结束后都会执行一次；`setUpClass( )`方法指在一个测试用例集执行前只执行一次；`tearDownClass( )`方法指在一个测试用例集执行后只执行一次。
（2）定义测试用例，名字以`test`开头：一个测试用例应该只测试一个方面，测试目的和测试内容应很明确。主要调用`assertEqual( )`、`assertRaises( )`等断言方法判断程序执行结果和预期值是否相符。
（3）调用`unittest.main( )`方法启动测试：如果测试未通过，会输出相应的错误提示；如果测试全部通过，则不显示任何东西。

### Unittest单元测试框架实例

`实例1：
（1）分别定义四个方法：setUp( )、tearDown( )、test_denglu( )、test_denglu1( )；
（2）使用setUp( )方法启动浏览器；
（3）使用tearDown( )方法关闭浏览器；
（4）使用test_denglu( )方法进入人力资源综合服务系统登录页面，输入账号和密码，单击“登录”按钮；
（5）使用test_denglu1( )方法进入人力资源综合服务系统登录页面，输入账号和密码，单击“登录”按钮，在人力资源综合服务系统页面单击“门户首页”按钮。
在PyCharm中进行代码编写：`

```python
import unittest #引入unittest
import time
from selenium import webdriver
class Denglu(unittest.TestCase):
    def setUp(self): #定义setUp()方法
        self.driver=webdriver.Chrome()
        self.driver.implicitly_wait(30)
        def tearDown(self): #定义tearDown()方法
        self.driver.quit()
    def test_denglu(self): #定义test_denglu()方法
        self.driver.get("http://192.168.X.XXX/suthr/logon")
        self.driver.find_element_by_name("username").send_keys("hrteacher")
        self.driver.find_element_by_name("password").send_keys("123456")
        self.driver.find_element_by_class_name("uppercase").click()
        time.sleep(5)
    def test_denglu1(self): #定义test_denglu1方法
        self.driver.get("http://192.168.X.XXX/suthr/logon") #进入人力资源综合服务系统登录页面
        self.driver.find_element_by_name("username").send_keys("hrteacher") #输入用户名 
        self.driver.find_element_by_name("password").send_keys("123456")#输入密码
        self.driver.find_element_by_class_name("uppercase").click() #单击“登录”按钮
        self.driver.find_element_by_link_text("门户首页").click()#单击“门户首页”按钮
        time.sleep(5)
if __name__ == '__main__':
    unittest.main()#调用unittest.main()方法启动测试

```

`实例2：
（1）分别定义四个方法：setUpClass( )、tearDownClass( )、test_denglu( )、test_denglu1( )；
（2）使用setUpClass( )方法启动浏览器；
（3）使用tearDownClass( )方法关闭浏览器；
（4）使用test_denglu( )方法进入人力资源综合服务系统登录页面，输入账号和密码，单击“登录”按钮；
（5）使用test_denglu1( )方法进入人力资源综合服务系统页面，在人力资源综合服务系统页面单击“门户首页”按钮。
在PyCharm中进行代码编写：`



```python
import unittest #引入unittest
import time
from selenium import webdriver
class Denglu(unittest.TestCase):
    @classmethod
    def setUpClass(cls): #定义setUpClass()方法
        cls.driver=webdriver.Chrome()
        cls.driver.implicitly_wait(30)
    @classmethod
    def tearDownClass(cls): #定义tearDownClass()方法
        cls.driver.quit()
    def test_denglu(cls): #定义test_denglu()方法
        cls.driver.get("http://192.168.X.XXX/suthr/logon")#进入人力资源综合服务系统登录页面 
        cls.driver.find_element_by_name("username").send_keys("hrteacher")#输入用户名 
        cls.driver.find_element_by_name("password").send_keys("123456")#输入密码
        cls.driver.find_element_by_class_name("uppercase").click()#单击“登录”按钮
        time.sleep(5)
    def test_denglu1(cls): #定义test_denglu1()方法
        cls.driver.find_element_by_link_text("门户首页").click()#单击“门户首页”按钮
        time.sleep(5)
if __name__ == '__main__':
    unittest.main()
#调用unittest.main()方法启动测试

```

# CSV文件读取

1．前期工作：在某个文件中创建一个Excel文件，放入三行数据，这里是姓名+年龄（可以自己随意写），然后另存为CSV文件格式。
2．读取步骤：（1）导入CSV代码库；（2）以只读形式打开文件；（3）由于打开文件的数据不能直接查看，所以要进行格式转换；（4）使用for循环打印除第一行标题之外的所有数据。

1. 案例1
```python
实例1
import csv
def read():
    path=r"./csvread1.csv"
    stream = open(path,'r')
    data = csv.reader(stream)
    list = []
    i =1
    for row in data:
        if i != 0:
            list.append(row)
        i = i +1
    return list
if __name__ == '__main__':
        data = read()
        for row in data:
            print(row)
##################################################### 

```
2. 案例2
```python
实例2
import csv

def getcsv():
    f = open("D:\\PythonProject\\项目自动化训练\\2022GZ\PoTest\\Page\\data.csv",'r',encoding='utf-8')
    L=[]
    i=0
    data = csv.reader(f)
    for j in data:
        if i!=0:
            L.append(j)
        i=i+1
    return L

print(getcsv())

# import csv
#
# def getCsv():
#     with open("./data.csv", encoding="utf8") as f:
#         f = csv.reader(f)
#         f.__next__()
#         data =[]
#         for t in f:
#             data.append(t)
#     return data
##################################################### 
@ddt
class Test(unittest.TestCase):

    def setUp(self) -> None:
        self.lg = LoginPage()
        self.lg.login('student','student')

    @data(*csvv.getcsv())
    @unpack
    def test_add(self,mingcheng,leibie):
        self.add = AddPage()
        self.add.add(mingcheng,leibie)
        time.sleep(2)

    def tearDown(self) -> None:
        self.add.quit()

if __name__ == '__main__':
    unittest.main()
```
3. 案例3
```python

#读取csv文件
def get_csv_file(line):
    # 文件路径需要自己修改成自己的文件路径
    with open(r"C:\Users\蒋英羽\Desktop\任务11.4：Web端—系统管理员 - 副本 (2)\任务实训指导书答案及源码\基于python\源码\Website\test_data\ccs.csv",encoding='utf-8-sig') as file:
        reader=csv.reader(file)
        for index,row in enumerate(reader,1):
            if index==line:
                return row

if __name__ == '__main__':
    data=get_csv_file(2)
    for row in data:
        print(row)
#######################################################
@ddt.ddt
class LoginTest(myunit.StartEnd):
  # @unittest.skip('skip this case')
    def test01_add_success(self):
        '''操作成功'''
        print("test case is start run...")
        test_date = function.get_csv_file(2)
        #创建参数接收测试数据
        test_user_login(self.driver,'hrteacher','123456')
        #登录
        test_user_add(self.driver,test_date[0],test_date[1])
        #输入测试数据
        time.sleep(3)
        function.inser_img(self.driver,"test01_add_null.png")
        # 截屏
        po = UserAdd(self.driver)
        # 设置参数接收数据
        self.assertIn(test_date[2], po.type_tjcg())
        # 断言对比测试用例是否正确
        print("test case is successful test end!")

```

# 数据驱动

使用数据驱动模式，可以根据业务分解测试数据，只需定义变量，通过外部或者自定义的数据使其参数化，从而避免使用之前测试脚本中固定的数据。可以将测试脚本与测试数据分离，使得测试脚本在不同数据集合下高度复用。这不仅可以增加复杂条件场景的测试覆盖，还可以减少测试脚本的编写与维护工作。

1．环境准备：安装ddt代码库，打开cmd命令行窗口，输入`pip install ddt`命令在线安装。
2．数据驱动步骤
（1）在头部导入ddt代码库：`import ddt`；
（2）在测试类前添加一个装饰器，表示这个类采用ddt代码库的方式实现数据驱动（`@ddt.ddt`）；
（3）在测试方法前使用`@ddt.data( )`指定数据来源。
3．代码编写思路：首先将测试数据单独存放，然后在编写脚本时调用存放的数据，逐条进行数据的读取。

`实例：`
`（1）进入人力资源综合服务系统登录页面；`
`（2）输入用户名和密码，单击“登录”按钮；`
`（3）单击人力资源综合服务系统页面左侧的“培训进修”按钮；`
`（4）在培训进修页面中的培训内容输入框中输入多组数据进行查询。`

```python
import unittest
from selenium import webdriver
from selenium.webdriver.common.by import By
from potest10_26_01.csvread import read
from ddt import ddt,data,unpack
# import csvread
@ddt
class ddt123(unittest.TestCase):
    def setUp(self):
        self.driver = webdriver.Chrome()
        self.driver.implicitly_wait(5)
    # @data(*read())
    # @unpack
    stream = read()
    @data(*stream)
    @unpack
    def test1(self,lost,nlost2):
        self.driver.get("http://192.168.5.10/pams")
        self.driver.find_element(By.NAME, "loginName").send_keys(lost)
        self.driver.find_element_by_name("password").send_keys(nlost2)
        self.driver.find_element(By.XPATH,'//*[@id="fmedit"]/div[4]/button').click()
        self.driver.find_element(By.PARTIAL_LINK_TEXT,"资产报废").click()
    def tearDown(self):
        self.driver.quit()
if __name__ == '__main__':
    unittest.main()
```

### 总结

####  [python数据处理之 ddt，@data， @unpack](https://raw.githubusercontent.com/azwwz/halo-synology-picture1/master/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/https://www.cnblogs.com/nbnuan/articles/10656724.html)

python 的unittest 没有自带数据驱动功能。

所以如果使用unittest，同时又想使用数据驱动，那么就可以使用DDT来完成。

DDT是 “Data-Driven Tests”的缩写，包含类的装饰器ddt和两个方法装饰器data（直接输入测试数据），file_data（可以从json或者yaml中获取测试数据）

------

【通常情况下，data中的数据按照一个参数传递给测试用例，如果data中含有多个数据，以元组，列表，字典等数据，需要自行在脚本中对数据进行分解或者使用unpack分解数据】

**说明：**

@ddt 读取单个测试数据：-----装饰测试类，继承自TestCase的类

@data（）---装饰测试方法，拿到几个数据数据就执行几条用例（可以以“*变量”传入括号；也可以直接括号放入数值，逗号隔开）

　　　　@data(a,b)  ------那么a和b各运行一次用例

　　　　@data([a,d],[c,d]) -----如果没有unpack，那么[a,b]当成一个参数传入用例运行；如果有unpack，那么[a,b]被分解开，按照用例中的两个参数传递

　　　　@file_data(filename)  ----对于json的文件，每一个json元素按照一个用例运行，可以依照python分解元组，列表或者字典的方式分解传入

@unpack ----解包，使用复杂的数据结构时，与此同时，测试方法的参数需要多个（参数的传值个数与解包后数量必须一一对应，“可以考虑用None”）

　　　　　 　　如果test_data的值很多（大于5）不建议使用unpack，可以考虑直接列表传出，索引取值（要注意参数不对等的情况）

 

【注意】使用请先导包

1.传列表

```
import  unittest
from ddt import  ddt,data,unpack
```



- unpack 的作用

```python
  @unpack    #在“脱外套”之后，针对你拿到的每一条数据根据逗号进行拆分
  def test_print_data(self,a,b):  #需要按拆出来的每条数据内的个数进行传参
```

- 参数名要和字典中的key对应

```python
import  unittest
from ddt import  ddt,data,unpack
test_data=[{'no':1,'name':'小李'},{'no':2,'name':'小张'}]

@ddt
class TestMath(unittest.TestCase):
    def setUp(self):
        pass

    @data(*test_data)
    @unpack    #在“脱外套”之后，针对你拿到的每一条数据根据逗号进行拆分
    def test_print_data(self,a,b):  #需要按拆出来的每条数据内的个数进行传参
        print(a)
        print(b)

#结果会报错，参数名需要与你的字典key对应
```

> 也可以不使用@package 返回的就是一个数组，直接填写list就是数组内容的拼接 list[0] 就是数组中的第一个元素

> 执行的时候一定要用main方法

# 数据断言

断言使用的主要是`assertEqual`方法，如何检查测试用例执行是否正确：
（1）通过比对页面元素的文本信息，检查测试用例执行结果的正确性，编写代码如下：`Find_element().text`
（2）通过对比页面标题信息，检查测试用例执行结果的正确性，编写代码如下：`Driver.title`
（3）通过对比网址信息，检查测试用例执行结果的正确性，编写代码如下：`Driver.current_url`
（4）通过比对页面元素的属性信息，检查测试用例执行结果的正确性，编写代码如下：`FindElement().get_attribute("value")`



`实例1：
1、进入人力资源综合服务系统登录页面；
2、输入用户名和密码，点击登录按钮；
3、在人力资源综合服务系统页面点击人资工作台按钮；
4、在人资工作台页面点击页面左侧的员工基本信息管理按钮；
5、点击员工信息管理按钮；
6、在员工信息管理页面点击录入员工按钮；
7、在录入员工页面对身份证号进行不输入信息和输入错误信息的数据驱动和断言代码编写，并进行异常错误处理和对异常错误进行截图。
测试数据，如图所示，在PyCharm中进行数据读取代码编写：`

```python
import time
from selenium import webdriver
import os
import unittest
from ddt import ddt,data,unpack
from selenium.webdriver import ActionChains

from potest10_26_01.csvread2 import read

@ddt
class duanyan(unittest.TestCase):
    def setUp(self):
        self.driver=webdriver.Chrome()
        self.driver.implicitly_wait(5)
    def tearDown(self):
        self.driver.quit()
    @data(*read())
    @unpack
    def test_denglu(self,sfz,dy):
        try:
            self.driver.get("http://192.168.5.7:12906/suthr")
            self.driver.find_element_by_id("username").send_keys('hrteacher')
            self.driver.find_element_by_id("password").send_keys('123456')
            self.driver.find_element_by_id("password").submit()
            self.driver.find_element_by_link_text("人资工作台").click()
            bz1 = self.driver.find_element_by_xpath('/html/body/div[4]/div[1]/div/ul/li[5]/a/span[1]')
            bz2 = self.driver.find_element_by_xpath('/html/body/div[4]/div[1]/div/ul/li[5]/ul/li[1]/a/span[1]')
            ActionChains(self.driver).move_to_element(bz1).perform()
            time.sleep(0.5)
            ActionChains(self.driver).click(bz2).perform()
            self.driver.find_element_by_xpath('//*[@id="pageContent"]/div[2]/div[2]/div/div/div[1]/div/div/button').click()
            self.driver.find_element_by_xpath('//*[@id="idCard"]').send_keys(sfz)
            self.driver.find_element_by_xpath('//*[@id="pageContent"]/div[3]/div/div[1]/button').click()
            sfze = self.driver.find_element_by_xpath('//*[@id="idCard-error"]').text
            self.assertEqual(sfze,dy)

        except:
            self.driver.execute_script("window.scrollTo(0,0)")
            time.sleep(2)
            # 方法 一
            # self.driver.get_screenshot_as_file("./123/%s123_%s.png"%(time.strftime('%Y-%m-%d-%H-%M-%S'),'asdfasdfasdf'))
            # 方法 二
            cutime = time.strftime("%Y-%m-%d-%H-%M-%S")
            currenpath = os.path.dirname(__file__)
            path = currenpath+"/456/"+cutime+'.png'
            self.driver.get_screenshot_as_file(path)
        finally:
            self.driver.quit()
if __name__ == '__main__':
    unittest.main()
```

> 这两种方法都不能自己创建文件夹，需要自己自行创建



# discover方法

使用unittest进行测试的话，如果是需要实现上百个测试用例，把它们全部写在一个test.py文件中，文件会越来越臃肿，后期维护页麻烦。此时可以将这些用例按照测试功能进行拆分，分散到不同的测试文件中。这时候我们可以通过discover方法来执行所有的测试用例。

discover使用格式：discover(start_dir,pattern='test\*.py')

找到指定目录下所有测试模块，并可递归查到子目录下的测试模块，只有匹配到文件名才能被加载。如果启动的不是顶层目录，那么顶层目录必须单独指定。

start_dir：要测试的模块名或测试用例目录

pattern='test\*.py'：表示用例文件名的匹配原则。此处匹配文件名以“test”开头的“.py”类型的文件，星号“*”表示任意多个字符


![image-20221026205806485](https://raw.githubusercontent.com/azwwz/halo-synology-picture1/master/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/image-20221026205806485.png)

```python
import unittest

testdir = "./discover"

discover=unittest.defaultTestLoader.discover(testdir,pattern="test*.py")

if __name__ == '__main__':
    unittest.TextTestRunner().run(discover)
```

# PageObject模式

## PO简介

Page Object是Selenium自动化测试项目开发实践的最佳设计模式之一，主要是将每一个页面设计为一个Class，其中包含页面中需要测试的元素，这样在Selenium测试页面中可以通过调用页面类来获取页面元素，这样巧妙的避免了当页面元素id或者位置变化时，需要改测试页面代码的情况。 

当页面元素id变化时，只需要更改测试页Class中页面的属性即可。 获取页面中元素的属性可以通过id，class或者XPath获取，在id唯一的情况下，可以使用id获取页面元素，否则可以使用XPath定位页面元素。

## PO原理

PageObject原理：将页面元素定位和对元素的操作行为封装成一个page类，实现对页面对象和测试用例的分离。
一条测试用例可能需要多个步骤操作元素，将每个步骤单独的封装成一个方法，在执行测试用例的时候调用封装好的操作。

## PO模式的作用

PageObject模式的优点：

（1）当某一个页面的元素发生变化，只需要修改该页面对象中的代码即可，不需要重复不断的修改测试用例。
（2）提高代码重用性，结构更加清晰，维护代码更容易。
（3）测试用例发生变化时，只需要修改少数页面对象即可。

`案例：通过下面的案例步骤在Pycharm中进行代码编写
案例步骤：
1、进入人力资源综合服务系统登录页面；
2、输入用户名和密码；
3、点击登录按钮。
在PyCharm中项目目录如下：`

![image-20221027154049469](https://raw.githubusercontent.com/azwwz/halo-synology-picture1/master/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/image-20221027154049469.png)

**(注：下划线的作用)**

**来自**：[Python中下划线的5种含义 - 知乎 (zhihu.com)](https://raw.githubusercontent.com/azwwz/halo-synology-picture1/master/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/https://zhuanlan.zhihu.com/p/36173202)

![img](https://raw.githubusercontent.com/azwwz/halo-synology-picture1/master/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/v2-cbc5c6037101c7d33cf0acd9f00a8cfa_r.jpg)

**(注：*号的作用)**

来自：[Python3中* 和 ** 运算符的用法是什么-Python教程-PHP中文网](https://raw.githubusercontent.com/azwwz/halo-synology-picture1/master/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/https://www.php.cn/python-tutorials-474944.html)

**BasePage.py**

```python
from time import sleep
# 封装好的基础页面，所有页面都要继承
class Page():
    # 初始化数据
    def __init__(self,driver):
        self.driver = driver
        self.base_url = "http://192.168.5.7:12906"
    # 写好对地址的一些中间操作
    # 这里的作用就是： 后续继续添加页面直接在相应页面添加相应的后面的url就可以了
    # 打开不同的页面，并对页面url进行断言
    def _open(self,url):
        url_ = self.base_url+url
        print ("This url is " + url)
        self.driver.maximize_window()
        self.driver.get(url_)
        sleep(2)
        assert self.driver.current_url != url_ , "did not lan on %s"%url_
    def open(self):
        self._open(self.url)

    def find_element(self,*loc):
        return self.driver.find_element(*loc)
    # 封装元素定位的方法

```

LoginPage.py

```python
from selenium.webdriver.common.by import By

from page.BasePage import *

class LoginPage(Page):
    # 在这里封装好 loginpage 需要用到的地址和定位
    url = '/suthr/logon'
    username_loc = (By.NAME,'username')
    password_loc = (By.NAME,'password')
    submit_loc = (By.ID,'loginBtn')

    # 在这边封装好定位需要用到的方法
    def type_username(self,username):
        self.find_element(*self.username_loc).clear()
        self.find_element(*self.username_loc).send_keys(username)

    def type_password(self,password):
        self.find_element(*self.password_loc).clear()
        self.find_element(*self.password_loc).send_keys(password)
    def type_submit(self):
        self.find_element(*self.submit_loc).click()
    # 在这边实例化整个对象，并封装成一个方法
def user_login(driver,username,password):
    login_page=LoginPage(driver)
    login_page.open()
    login_page.type_username(username)
    login_page.type_password(password)
    login_page.type_submit()
```

test_login.py

```python
import time
from selenium import  webdriver
from page.LoginPage import *

driver = webdriver.Chrome()
user_login(driver,'hrteacher','123456')
time.sleep(3)
driver.quit()
```



# 最后题目

![image-20221027212316786](https://raw.githubusercontent.com/azwwz/halo-synology-picture1/master/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/image-20221027212316786.png)



## driver.py

```python
from selenium import webdriver

def browser():
    driver=webdriver.Chrome()
    #打开谷歌浏览器
    return driver

```

## function.py

```python
import os
import smtplib
from email.mime.text import MIMEText
from email.header import Header
import csv

#截图方法
def inser_img(driver,filename):
    #获取当前模块所在路径
    func_path=os.path.dirname(__file__)
    #获取test_case目录
    base_dir=os.path.dirname(func_path)
    #将路径转化为字符串
    base_dir=str(base_dir)
    #对路径的字符串进行替换
    base_dir=base_dir.replace('\\','/')
    #获取项目文件的根目录路径
    base=base_dir.split('/Website')[0]
    #指定截图存放路径
    filepath=base+'/Website/test_report/screenshot/'+filename
    driver.get_screenshot_as_file(filepath)

#查找最新的测试报告
def latest_report(report_dir):
    lists = os.listdir(report_dir)
    lists.sort(key=lambda fn: os.path.getatime(report_dir + '\\' + fn))
    file = os.path.join(report_dir, lists[-1])
    return file

#将测试报告发送到邮件
def send_mail(latest_report):
    #这里所有的参数使用的是163邮箱，如果使用别的邮箱需要自己配置参数
    f=open(latest_report,'rb')
    mail_content=f.read()
    f.close()
    smtpserver = 'smtp.163.com'
    user = 'XXX@163.com'                #填入自己的邮箱账号
    password = 'UCSLGPTXXXMFAX'      #填入自己的授权码，注意非邮件密码

    sender = 'XXX@163.com'    #填入发送邮箱的账号
    receives = 'XXX@qq.com'  #填入接收邮箱的账号

    subject = 'Selenium自动化测试报告'

    msg = MIMEText(mail_content, 'html', 'utf-8')
    msg['Subject'] = Header(subject, 'utf-8')
    msg['From'] = sender
    msg['To'] = receives

    smtp = smtplib.SMTP_SSL(smtpserver, 465)
    smtp.helo(smtpserver)
    smtp.ehlo(smtpserver)
    smtp.login(user, password)

    print("Start send email...")
    smtp.sendmail(sender, receives, msg.as_string())
    smtp.quit()
    print("Send email end!")

#读取csv文件
def get_csv_file(line):
    # 文件路径需要自己修改成自己的文件路径
    with open(r"C:\Users\蒋英羽\Desktop\任务11.4：Web端—系统管理员 - 副本 (2)\任务实训指导书答案及源码\基于python\源码\Website\test_data\ccs.csv",encoding='utf-8-sig') as file:
        reader=csv.reader(file)
        for index,row in enumerate(reader,1):
            if index==line:
                return row

if __name__ == '__main__':
    data=get_csv_file(2)
    for row in data:
        print(row)
```

## myunit.py

```python
import unittest
from driver.driver import *

class StartEnd(unittest.TestCase):
    def setUp(self):
        self.driver=browser()
        self.driver.implicitly_wait(10)
        self.driver.maximize_window()

    def tearDown(self):
        self.driver.quit()
```

## AddPage.py

```python
from selenium.webdriver.common.by import By
from Website.test_case.page_object.BasePage import *
from time import sleep

class UserAdd(Page):
    url='/'
    Rzgzt_loc=(By.LINK_TEXT,'人资工作台')        #定位人资工作台按钮
    Mhhtgl_loc=(By.LINK_TEXT,'门户后台管理')         #定位门户后台管理按钮
    Yqljgl_loc=(By.XPATH,'/html/body/div[4]/div[1]/div/ul/li[16]/ul/li[4]/a')         #定位友情链接管理按钮
    Tjlj_loc=(By.XPATH,'//*[@id="searchForm"]/div/button[2]')  #定位添加链接按钮
    Ljmc_loc=(By.ID,'title')  #定位链接名称输入框
    Ljdz_loc=(By.ID,'url')  #定位链接地址输入框
    Bcan_loc=(By.XPATH,'//*[@id="ajax-modal"]/div[3]/button[1]')            #定位保存按钮
    Tsxx_loc=(By.ID,'title-error')             #定位连接名称提示消息
    Tsxxdz_loc=(By.ID,'url-error')             #定位连接地址提示消息
    Tstc_loc=(By.CLASS_NAME,'bootbox-body')             #定位弹窗提示文字信息
    Tjcg_loc=(By.XPATH,'//*[@id="pageContent"]/div[2]/div/div/div/div[2]/table/tbody/tr/td[2]')            #添加成功文本

    def type_Rzgzt(self):
        self.find_element(*self.Rzgzt_loc).click()
    #点击人资工作台按钮
    def type_Mhhtgl(self):
        self.find_element(*self.Mhhtgl_loc).click()
    #点击门户后台管理按钮
    def type_Yqljgl(self):
        self.find_element(*self.Yqljgl_loc).click()
    #点击友情链接管理按钮
    def type_Tjlj(self):
        self.find_element(*self.Tjlj_loc).click()
    #点击添加链接按钮
    def type_Ljmc(self,Name):
        self.find_element(*self.Ljmc_loc).clear()
        self.find_element(*self.Ljmc_loc).send_keys(Name)
    #输入链接名称
    def type_Ljdz(self,dizhi):
        self.find_element(*self.Ljdz_loc).clear()
        self.find_element(*self.Ljdz_loc).send_keys(dizhi)
    #输入链接地址
    def type_Bcan(self):
        self.find_element(*self.Bcan_loc).click()
    # 点击保存按钮
    def type_Tsxx(self):
        return self.find_element(*self.Tsxx_loc).text
    # 获取连接名称提示信息
    def type_Tsxxdz(self):
        return self.find_element(*self.Tsxxdz_loc).text
    # 获取连接地址提示信息
    def type_Tstc(self):
        return self.find_element(*self.Tstc_loc).get_attribute("innerHTML")
    # 读取弹窗文字信息
    def type_tjcg(self):
        return self.find_element(*self.Tjcg_loc).text
    # 获取添加成功文本
    def type_gd(self):
        return self.driver.execute_script('window.scrollBy(0,1000)')

def test_user_add(driver,Name,dizhi):
    add_page=UserAdd(driver)
    add_page.type_Rzgzt()
    sleep(1)
    add_page.type_gd()
    add_page.type_Mhhtgl()
    sleep(3)
    add_page.type_Yqljgl()
    sleep(1)
    add_page.type_Tjlj()
    sleep(1)
    add_page.type_Ljmc(Name)
    sleep(1)
    add_page.type_Ljdz(dizhi)
    sleep(1)
    add_page.type_Bcan()
    #封装添加功能


```

## BasePage.py

```python
from time import sleep


class Page():
    """基础类，用于所以页面对象类继承"""

    def __init__(self, driver):
        self.driver = driver
        self.base_url = 'http://192.168.16.156/suthr/logon'
        self.timeout = 10

    def _open(self, url):
        url_ = self.base_url + url
        print("Test page is %s" % url_)
        self.driver.maximize_window()
        self.driver.get(url_)
        sleep(2)
        assert self.driver.current_url == url_, 'Did not land on %s' % url_

    def open(self):
        self._open(self.url)

    def find_element(self, *loc):
        return self.driver.find_element(*loc)


```

## LoginPage.py

```python
from Website.test_case.page_object.BasePage import *
from  selenium.webdriver.common.by import By


class LoginPage(Page):
    url='/'

    username_loc=(By.NAME,'username')       #定位用户名输入框
    password_loc=(By.NAME,'password')       #定位密码输入框
    submit_loc=(By.ID,'loginBtn')       #定位登录按钮



    def type_username(self,username):
        self.find_element(*self.username_loc).clear()
        self.find_element(*self.username_loc).send_keys(username)
    #输入用户名
    def type_password(self,password):
        self.find_element(*self.password_loc).clear()
        self.find_element(*self.password_loc).send_keys(password)
    # 输入密码
    def type_submit(self):
        self.find_element(*self.submit_loc).click()
    #点击登录按钮



def test_user_login(driver,username,password):
    login_page=LoginPage(driver)
    login_page.open()
    login_page.type_username(username)
    login_page.type_password(password)
    login_page.type_submit()


    #封装登录功能
```

## test_add.py

```python
import unittest
from Website.test_case.model import function,myunit
from Website.test_case.page_object.LoginPage import *
from Website.test_case.page_object.AddPage import *
import time
import ddt

@ddt.ddt
class LoginTest(myunit.StartEnd):
  # @unittest.skip('skip this case')
    def test01_add_success(self):
        '''操作成功'''
        print("test case is start run...")
        test_date = function.get_csv_file(2)
        #创建参数接收测试数据
        test_user_login(self.driver,'hrteacher','123456')
        #登录
        test_user_add(self.driver,test_date[0],test_date[1])
        #输入测试数据
        time.sleep(3)
        function.inser_img(self.driver,"test01_add_null.png")
        # 截屏
        po = UserAdd(self.driver)
        # 设置参数接收数据
        self.assertIn(test_date[2], po.type_tjcg())
        # 断言对比测试用例是否正确
        print("test case is successful test end!")

    def test02_add_null(self):
        '''连接名称为空'''
        print("test case is start run...")
        test_date = function.get_csv_file(3)
        #创建参数接收测试数据
        test_user_login(self.driver,'hrteacher','123456')
        #登录
        test_user_add(self.driver,test_date[0],test_date[1])
        #输入测试数据
        time.sleep(3)
        function.inser_img(self.driver,"test01_add_null.png")
        # 截屏
        po = UserAdd(self.driver)
        # 设置参数接收数据
        self.assertIn(test_date[2], po.type_Tsxx())
        # 断言对比测试用例是否正确
        print("test case is successful test end!")

    def test03_add_null(self):
        '''连接地址为空'''
        print("test case is start run...")
        test_date = function.get_csv_file(4)
        #创建参数接收测试数据
        test_user_login(self.driver,'hrteacher','123456')
        #登录
        test_user_add(self.driver,test_date[0],test_date[1])
        #输入测试数据
        time.sleep(3)
        function.inser_img(self.driver,"test01_add_null.png")
        # 截屏
        po = UserAdd(self.driver)
        # 设置参数接收数据
        self.assertIn(test_date[2], po.type_Tsxxdz())
        # 断言对比测试用例是否正确
        print("test case is successful test end!")

    def test04_add_repeat(self):
        '''连接名称重复'''
        print("test case is start run...")
        test_date = function.get_csv_file(5)
        #创建参数接收测试数据
        test_user_login(self.driver,'hrteacher','123456')
        #登录
        test_user_add(self.driver,test_date[0],test_date[1])
        #输入测试数据
        time.sleep(3)
        function.inser_img(self.driver,"test01_add_null.png")
        # 截屏
        po = UserAdd(self.driver)
        # 设置参数接收数据
        self.assertIn(test_date[2], po.type_Tstc())
        # 断言对比测试用例是否正确
        print("test case is successful test end!")
```

## ccs.csv

```python
测试数据
测试连接,www.ceshi.com,测试连接
,www.ceshi.com,必须填写
测试链接,,必须填写
测试连接,www.ceshi.com,链接名称已经存在，请重新填写！
```

## runtest.py

```python
import unittest
from Website.test_case.model.function import *
from HTMLTestRunner import HTMLTestRunner
import time

report_dir='./test_report'
test_dir='./test_case'

print("start run test case")
discover=unittest.defaultTestLoader.discover(test_dir,pattern="test_add.py")

now=time.strftime("%Y-%m-%d %H_%M_%S")
report_name=report_dir+'/'+now+'result.html'

print("start write report..")
with open(report_name,'wb') as f:
    runner=HTMLTestRunner(stream=f,title="Test Report" ,description="localhost login test")
    runner.run(discover)
    f.close()

print("find latest report")
latest_report=latest_report(report_dir)

print("send email report..")
send_mail(latest_report)

print("Test end")
```





## 自己跟着敲的

![image-20221028102848155](https://raw.githubusercontent.com/azwwz/halo-synology-picture1/master/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/image-20221028102848155.png)

![image-20221028102955027](https://raw.githubusercontent.com/azwwz/halo-synology-picture1/master/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/image-20221028102955027.png)

- os出来的路径就是"/"

- 无需字符串转化

- 也不用`base_dir=base_dir.replace('\\','/')`转换

  

  

  **`for index,row in enumerate(reader,1):`是什么意思**

  ![image-20221028103723325](https://raw.githubusercontent.com/azwwz/halo-synology-picture1/master/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/image-20221028103723325.png)

**总而言之enumerate就是[枚举](https://raw.githubusercontent.com/azwwz/halo-synology-picture1/master/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/https://so.csdn.net/so/search?q=枚举&spm=1001.2101.3001.7020)的意思，把元素一个个列举出来，第一个是什么，第二个是什么，所以他返回的是元素以及对应的索引。**

```python
line = [1,2,3,4,5,6,7,8,9]
for i,j in enumerate(line):
    print(i,j)
#以下是输出结果
0 1
1 2
2 3
3 4
4 5
5 6
6 7
7 8
8 9
#eg2:
line = ["a","b","c","d","e"]
for i,j in enumerate(line):
    print(i,j)
#output:
0 a
1 b
2 c
3 d
4 e
```
